diff --git a/Assets/gamecore/scripts/AudioManager.cs b/Assets/gamecore/scripts/AudioManager.cs
new file mode 100644
index 0000000..c4cd959
--- /dev/null
+++ b/Assets/gamecore/scripts/AudioManager.cs
@@ -0,0 +1,332 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace GameCore
+{
+    [DisallowMultipleComponent]
+    public class AudioManager : MonoBehaviour
+    {
+        public static AudioManager Instance { get; private set; }
+
+        [Header("Music Sources")]
+        [SerializeField] private AudioSource baseMusicSource;
+        [SerializeField] private AudioSource combatMusicSource;
+        [SerializeField] private AudioSource bossMusicSource;
+
+        [Header("Music Settings")]
+        [SerializeField, Min(0f)] private float musicFadeDuration = 0.5f;
+        [SerializeField, Range(0f, 1f)] private float baseLayerVolume = 1f;
+        [SerializeField, Range(0f, 1f)] private float combatLayerVolume = 1f;
+        [SerializeField, Range(0f, 1f)] private float bossLayerVolume = 1f;
+        [SerializeField, Range(0f, 1f)] private float musicVolume = 1f;
+
+        [Header("SFX Settings")]
+        [SerializeField, Min(1)] private int sfxPoolSize = 8;
+        [SerializeField, Range(0f, 1f)] private float sfxVolume = 1f;
+        [SerializeField] private List<AudioSource> sfxSources = new List<AudioSource>();
+
+        private readonly Dictionary<AudioSource, Coroutine> activeFadeRoutines = new Dictionary<AudioSource, Coroutine>();
+        private int nextSfxIndex;
+
+        private void Awake()
+        {
+            if (Instance != null && Instance != this)
+            {
+                Destroy(gameObject);
+                return;
+            }
+
+            Instance = this;
+            DontDestroyOnLoad(gameObject);
+
+            if (string.IsNullOrEmpty(gameObject.name) || gameObject.name != "audio_manager")
+            {
+                gameObject.name = "audio_manager";
+            }
+
+            EnsureMusicSources();
+            EnsureSfxPool();
+            ApplyCurrentVolumes();
+        }
+
+        private void OnDestroy()
+        {
+            if (Instance == this)
+            {
+                Instance = null;
+            }
+        }
+
+        private void OnValidate()
+        {
+            sfxPoolSize = Mathf.Max(1, sfxPoolSize);
+            musicFadeDuration = Mathf.Max(0f, musicFadeDuration);
+            musicVolume = Mathf.Clamp01(musicVolume);
+            sfxVolume = Mathf.Clamp01(sfxVolume);
+            baseLayerVolume = Mathf.Clamp01(baseLayerVolume);
+            combatLayerVolume = Mathf.Clamp01(combatLayerVolume);
+            bossLayerVolume = Mathf.Clamp01(bossLayerVolume);
+
+            if (!Application.isPlaying)
+            {
+                return;
+            }
+
+            ApplyCurrentVolumes();
+        }
+
+        public void PlayBaseMusic(AudioClip clip)
+        {
+            PlayMusicLayer(baseMusicSource, clip, baseLayerVolume);
+        }
+
+        public void PlayCombatMusic(AudioClip clip)
+        {
+            PlayMusicLayer(combatMusicSource, clip, combatLayerVolume);
+        }
+
+        public void PlayBossMusic(AudioClip clip)
+        {
+            PlayMusicLayer(bossMusicSource, clip, bossLayerVolume);
+        }
+
+        public void StopBaseMusic()
+        {
+            StopMusicLayer(baseMusicSource);
+        }
+
+        public void StopCombatMusic()
+        {
+            StopMusicLayer(combatMusicSource);
+        }
+
+        public void StopBossMusic()
+        {
+            StopMusicLayer(bossMusicSource);
+        }
+
+        public void PlaySFX(AudioClip clip, float volume = 1f)
+        {
+            if (clip == null || sfxSources.Count == 0)
+            {
+                return;
+            }
+
+            var source = sfxSources[nextSfxIndex];
+            nextSfxIndex = (nextSfxIndex + 1) % sfxSources.Count;
+
+            source.PlayOneShot(clip, Mathf.Clamp01(volume) * sfxVolume);
+        }
+
+        public void SetMusicVolume(float value)
+        {
+            musicVolume = Mathf.Clamp01(value);
+            ApplyCurrentVolumes();
+        }
+
+        public void SetSFXVolume(float value)
+        {
+            sfxVolume = Mathf.Clamp01(value);
+        }
+
+        private void PlayMusicLayer(AudioSource source, AudioClip clip, float layerVolume)
+        {
+            if (source == null)
+            {
+                return;
+            }
+
+            if (clip == null)
+            {
+                FadeTo(source, 0f, true);
+                return;
+            }
+
+            if (source.clip != clip)
+            {
+                source.clip = clip;
+            }
+
+            source.loop = true;
+            if (!source.isPlaying)
+            {
+                source.Play();
+            }
+
+            FadeTo(source, layerVolume * musicVolume, false);
+        }
+
+        private void StopMusicLayer(AudioSource source)
+        {
+            if (source == null)
+            {
+                return;
+            }
+
+            FadeTo(source, 0f, true);
+        }
+
+        private void FadeTo(AudioSource source, float targetVolume, bool stopWhenDone)
+        {
+            targetVolume = Mathf.Clamp01(targetVolume);
+
+            if (activeFadeRoutines.TryGetValue(source, out var runningRoutine) && runningRoutine != null)
+            {
+                StopCoroutine(runningRoutine);
+            }
+
+            if (musicFadeDuration <= 0f)
+            {
+                source.volume = targetVolume;
+                if (stopWhenDone && Mathf.Approximately(targetVolume, 0f))
+                {
+                    source.Stop();
+                }
+
+                activeFadeRoutines[source] = null;
+                return;
+            }
+
+            activeFadeRoutines[source] = StartCoroutine(FadeRoutine(source, targetVolume, stopWhenDone));
+        }
+
+        private IEnumerator FadeRoutine(AudioSource source, float targetVolume, bool stopWhenDone)
+        {
+            var startVolume = source.volume;
+            var elapsed = 0f;
+
+            while (elapsed < musicFadeDuration)
+            {
+                elapsed += Time.unscaledDeltaTime;
+                var t = Mathf.Clamp01(elapsed / musicFadeDuration);
+                source.volume = Mathf.Lerp(startVolume, targetVolume, t);
+                yield return null;
+            }
+
+            source.volume = targetVolume;
+            if (stopWhenDone && Mathf.Approximately(targetVolume, 0f))
+            {
+                source.Stop();
+            }
+
+            activeFadeRoutines[source] = null;
+        }
+
+        private void ApplyCurrentVolumes()
+        {
+            UpdateLayerVolume(baseMusicSource, baseLayerVolume);
+            UpdateLayerVolume(combatMusicSource, combatLayerVolume);
+            UpdateLayerVolume(bossMusicSource, bossLayerVolume);
+        }
+
+        private void UpdateLayerVolume(AudioSource source, float layerVolume)
+        {
+            if (source == null)
+            {
+                return;
+            }
+
+            if (!source.isPlaying)
+            {
+                source.volume = 0f;
+                return;
+            }
+
+            source.volume = Mathf.Clamp01(layerVolume * musicVolume);
+        }
+
+        private void EnsureMusicSources()
+        {
+            EnsureMusicSource(ref baseMusicSource, "base_music_source");
+            EnsureMusicSource(ref combatMusicSource, "combat_music_source");
+            EnsureMusicSource(ref bossMusicSource, "boss_music_source");
+        }
+
+        private void EnsureMusicSource(ref AudioSource source, string fallbackName)
+        {
+            if (source == null)
+            {
+                source = CreateOrGetChildSource(fallbackName);
+            }
+
+            ConfigureMusicSource(source);
+        }
+
+        private void EnsureSfxPool()
+        {
+            if (sfxSources == null)
+            {
+                sfxSources = new List<AudioSource>();
+            }
+
+            sfxSources.RemoveAll(item => item == null);
+
+            while (sfxSources.Count < sfxPoolSize)
+            {
+                var source = CreateOrGetChildSource($"sfx_source_{sfxSources.Count}");
+                ConfigureSfxSource(source);
+                sfxSources.Add(source);
+            }
+
+            for (var i = 0; i < sfxSources.Count; i++)
+            {
+                if (sfxSources[i] == null)
+                {
+                    sfxSources[i] = CreateOrGetChildSource($"sfx_source_{i}");
+                }
+
+                ConfigureSfxSource(sfxSources[i]);
+            }
+
+            if (sfxSources.Count > sfxPoolSize)
+            {
+                sfxSources.RemoveRange(sfxPoolSize, sfxSources.Count - sfxPoolSize);
+            }
+
+            if (nextSfxIndex >= sfxSources.Count)
+            {
+                nextSfxIndex = 0;
+            }
+        }
+
+        private AudioSource CreateOrGetChildSource(string childName)
+        {
+            var child = transform.Find(childName);
+            if (child == null)
+            {
+                var childObject = new GameObject(childName);
+                childObject.transform.SetParent(transform, false);
+                child = childObject.transform;
+            }
+
+            var source = child.GetComponent<AudioSource>();
+            if (source == null)
+            {
+                source = child.gameObject.AddComponent<AudioSource>();
+            }
+
+            return source;
+        }
+
+        private static void ConfigureMusicSource(AudioSource source)
+        {
+            source.playOnAwake = false;
+            source.loop = true;
+            source.volume = 0f;
+        }
+
+        private static void ConfigureSfxSource(AudioSource source)
+        {
+            source.playOnAwake = false;
+            source.loop = false;
+        }
+
+        private void Reset()
+        {
+            gameObject.name = "audio_manager";
+            EnsureMusicSources();
+            EnsureSfxPool();
+        }
+    }
+}
